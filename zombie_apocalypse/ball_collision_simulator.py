"""
Ball/ball collision simulator, currently spawns balls via mouse clicks,
Implemented with linear collision check using spatial partition
"""

try:
    import simplegui
except ImportError:
    import SimpleGUICS2Pygame.simpleguics2pygame as simplegui
import random
import time
import math

# global constants
BALL_RADIUS = 25
BALL_DIAMETER = 2 * BALL_RADIUS
BALL_DIAMETER_SQUARED = BALL_DIAMETER ** 2
VEL_RANGE = 6

CANVAS_WIDTH = 800
CANVAS_HEIGHT = 600

# integer division operator for working out the # of cells
GRID_WIDTH = CANVAS_WIDTH // BALL_DIAMETER
GRID_HEIGHT = CANVAS_HEIGHT // BALL_DIAMETER


def dot(vec1, vec2):
    """
    :param vec1: 
    :param vec2: 
    :return: Return the dot product of two 2D vectors
    """
    return vec1[0] * vec2[0] + vec1[1] * vec2[1]


class Ball:
    """
    Representation for balls used in collision simulations
    """

    def __init__(self, position, velocity, number):
        """
        Create balls, takes the position of the ball's center(in pixels)
        and its velocity in pixels per update
        """
        self._pos = position
        self._vel = velocity
        self._num = number

    def get_pos(self):
        return self._pos

    def get_vel(self):
        return self._vel

    def get_num(self):
        return self._num

    def set_vel(self, velocity):
        self._vel = velocity

    def grid_index(self):
        horiz_index = int(self._pos[0] // BALL_DIAMETER)
        vert_index = int(self._pos[1] // BALL_DIAMETER)

        return [min(max(0, horiz_index), GRID_WIDTH - 1), min(max(0, vert_index), GRID_HEIGHT - 1)]

    def update(self, grid):
        """
        THE CORE of this simulator!!!!!!!!!!
        update the position and velocity of a ball
        :param grid: the 2D array representing the grid generated by partitioning the canvas
        :return: 
        """

        # Update position
        self._pos[0] += self._vel[0]
        self._pos[1] += self._vel[1]

        # update velocity due to hitting the walls
        if (self._pos[0] <= BALL_RADIUS) or (self._pos[0] >= CANVAS_WIDTH - 1 - BALL_RADIUS):
            self._vel[0] = -self._vel[0]
        if (self._pos[1] <= BALL_RADIUS) or (self._pos[1] >= CANVAS_HEIGHT - 1 - BALL_RADIUS):
            self._vel[1] = -self._vel[1]

        # test for collision with balls that lie in nearby grid elements
        ball_index = self.grid_index()
        for x_index in range(max(0, ball_index[0] - 1), min(ball_index[0] + 2, GRID_WIDTH)):
            for y_index in range(max(0, ball_index[1] - 1), min(ball_index[1] + 2, GRID_HEIGHT)):
                for other_ball in grid[x_index][y_index]:
                    if (self._num < other_ball.get_num()) and self.collide(other_ball):
                        self.bounce(other_ball)

    def collide(self, other_ball):
        """
        Method to check whether two balls collide
        :param other_ball: 
        :return: 
        """
        other_ball_pos = other_ball.get_pos()
        distance_squared = (other_ball_pos[0] - self._pos[0]) ** 2 + \
                           (other_ball_pos[1] - self._pos[1]) ** 2
        return distance_squared <= BALL_DIAMETER_SQUARED

    def bounce(self, other_ball):
        """
        update the velocities for two colliding balls
        :param other_ball: 
        :return: 
        """
        # Compute normal for collision
        other_ball_pos = other_ball.get_pos()
        center_chord = [other_ball_pos[0] - self._pos[0], other_ball_pos[1] - self._pos[1]]
        # seems to be abundant
        chord_length = math.sqrt(center_chord[0] ** 2 + center_chord[1] ** 2)
        # have it become a unit vector
        normal = [center_chord[0] / chord_length, center_chord[1] / chord_length]

        # Compute tangential component of velocities for both balls
        other_ball_vel = other_ball.get_vel()
        self_dot = dot(normal, self._vel)
        self_tangent = [self._vel[0] - self_dot * normal[0],
                        self._vel[1] - self_dot * normal[1]]
        other_dot = dot(normal, other_ball_vel)
        other_tangent = [other_ball_vel[0] - other_dot * normal[0],
                         other_ball_vel[1] - other_dot * normal[1]]

        # Update velocities for both balls
        self._vel[0] = self_tangent[0] + other_dot * normal[0]
        self._vel[1] = self_tangent[1] + other_dot * normal[1]
        other_ball_vel = [other_tangent[0] + self_dot * normal[0],
                          other_tangent[1] + self_dot * normal[1]]
        other_ball.set_vel(other_ball_vel)

    def draw(self, canvas):
        """
        Draw a ball with given canvas with BALL_RADIUS at specified position
        :param self: 
        :param canvas: 
        :return: 
        """
        # dic = {0: "White", 1: "Red", 2: "Yellow", 3:"Blue", 4:"Orange", 5: "Green"}
        # dic = {0: "White", 1: "Red"}
        # ran = random.randrange(0, 2)
        # canvas.draw_circle(self._pos, BALL_RADIUS, 1, dic[ran], dic[ran])
        canvas.draw_circle(self._pos, BALL_RADIUS, 1, "White", "White")


class Simulation:
    """
    Class representation for ball physics simulation
    """

    def __init__(self):
        """
        Create a simulation
        """
        self._ball_list = []

    def add_ball(self, pos):
        """
        Add a ball with a random velocity to the similation
        :param pos: 
        :return: 
        """
        # the range of x_vel and y_vel===>[-1, 1]
        x_vel = random.randrange(-VEL_RANGE, VEL_RANGE + 1) / float(VEL_RANGE)
        y_vel = random.randrange(-VEL_RANGE, VEL_RANGE + 1) / float(VEL_RANGE)
        new_ball = Ball(list(pos), [x_vel, y_vel], len(self._ball_list))

        # avoid newly spawned ball colliding existing balls
        for ball in self._ball_list:
            if new_ball.collide(ball):
                return
        self._ball_list.append(new_ball)

    def num_balls(self):
        """
        Return the number of balls in the simulation
        """
        return len(self._ball_list)

    def update(self):
        """
        Do one physical update for simulation
        :return: 
        """
        # Initialize grid to accelerate collisions
        grid = [[[] for dummy_y in range(GRID_HEIGHT)] for dummy_x in range(GRID_WIDTH)]
        # print len(grid[0])
        for ball in self._ball_list:
            ball_index = ball.grid_index()
            grid[ball_index[0]][ball_index[1]].append(ball)

        #Update every balls!!!!!!!!!!!!!!!!
        for ball in self._ball_list:
            ball.update(grid)

    def draw(self, canvas):
        """
        Draw the balls in the simulation
        """
        for ball in self._ball_list:
            ball.draw(canvas)


class SimulationGUI:
    """
    Container for interactive content
    """

    def __init__(self):
        """ 
        Initializer to create frame, sets handlers and initialize list of balls to be empty
        """
        self.simulation = Simulation()
        self._frame = simplegui.create_frame("ball/ball collision simulator",
                                             CANVAS_WIDTH, CANVAS_HEIGHT)
        self._frame.set_draw_handler(self.draw)
        self._frame.set_mouseclick_handler(self.click)
        self._prev_time = time.time()
        self._frame_rate = 60.0

    def start(self):
        """
        Start frame
        """
        self._frame.start()

    def click(self, pos):
        """ 
        Event handler for mouse clicks, takes mouse position pos, 
        adds new ball to ball_list at pos if space is empty
        """

        # Create random velocity with max of one pixel per update
        self.simulation.add_ball(pos)

    def draw(self, canvas):
        """
        Handler for draw events, draws balls and some stats
        """

        # Compute frame_rate
        current_time = time.time()
        if current_time != self._prev_time:
            self._frame_rate = 0.99 * self._frame_rate + (0.01 / (current_time - self._prev_time))
        self._prev_time = current_time

        # Display number of balls and frame rate
        canvas.draw_text("Frame rate " + str(int(self._frame_rate // 1)), [550, 24], 24, "White")
        canvas.draw_text("Number of balls " + str(self.simulation.num_balls()), [50, 24], 24, "White")

        # Draw and update balls
        self.simulation.update()
        self.simulation.draw(canvas)
        # print "draw"


# Start interactive simulation
def run_gui():
    """
    Encapsulate frame
    """
    gui = SimulationGUI()
    gui.start()


run_gui()
